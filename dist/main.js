(()=>{"use strict";function t(e){if(e.length<=1)return e;const r=Math.floor(e.length/2);return function(t,e){const r=[];let n=0,l=0,o=0;for(;n<t.length&&l<e.length;)t[n]<e[l]?(r[o]=t[n],n++):(r[o]=e[l],l++),o++;for(;n<t.length;)r[o]=t[n],n++,o++;for(;l<e.length;)r[o]=e[l],l++,o++;return r}(t(e.slice(0,r)),t(e.slice(r)))}const e=function(e){return function(t){const e=new Set(t);return Array.from(e)}(t(e))},r=class{constructor(t){this.node=t,this.left=null,this.right=null}};class n{constructor(t){this.root=this.buildTree(t,0,t.length-1)}buildTree(t,e,n){if(e>n)return null;const l=Math.floor((e+n)/2),o=new r(t[l]);return o.left=this.buildTree(t,e,l-1),o.right=this.buildTree(t,l+1,n),o}insert(t,e=this.root){let n=e;return null===n?(n=new r(t),n):(t<n.node?n.left=this.insert(t,n.left):t>n.node&&(n.right=this.insert(t,n.right)),n)}find(t,e=this.root){return e.node===t?e:e.node!==t&&null===e.left&&null===e.right||t<e.node&&null===e.left||t>e.node&&null===e.right?(console.log(`This tree does not contain ${t}.`),null):"number"!=typeof t?(console.log("Please enter a number."),null):t<e.node?this.find(t,e.left):this.find(t,e.right)}delete(t,e=this.root){const r=e;if(null===r)return r;if(t<r.node)r.left=this.delete(t,r.left);else if(t>r.node)r.right=this.delete(t,r.right);else{if(null===r.left)return r.right;if(null===r.right)return r.left;r.node=function(t){let e=t.right;for(;null!==e.left;)e=e.left;return e.node}(r),r.right=this.delete(r.node,r.right)}return r}levelOrder(){if(null===this.root)return null;const t=[],e=[];for(t.push(this.root);t.length>0;){const r=t.shift();r.left&&t.push(r.left),r.right&&t.push(r.right),e.push(r.node)}return e}preOrder(t=this.root,e=[]){return null===t?null:(e.push(t.node),this.preOrder(t.left,e),this.preOrder(t.right,e),e)}inOrder(t=this.root,e=[]){return null===t?null:(this.inOrder(t.left,e),e.push(t.node),this.inOrder(t.right,e),e)}postOrder(t=this.root,e=[]){return null===t?null:(this.postOrder(t.left,e),this.postOrder(t.right,e),e.push(t.node),e)}height(t,e=this.find(t)){if(null===e)return 0;const r=Math.max(this.height(t,e.left),this.height(t,e.right))+0,n=Math.max(this.height(t,e.left),this.height(t,e.right))+1;return null===e.left&&null===e.right?r:n}depth(t,e=this.root){return null===this.find(t)||e.node===t?0:t<e.node?this.depth(t,e.left)+1:this.depth(t,e.right)+1}isBalanced(t=this.root){if(null===t)return!0;const e=this.height(t.node,t.left)-this.height(t.node,t.right);return e<2&&e>-2&&(this.isBalanced(t.left),this.isBalanced(t.right),!0)}rebalance(){const t=this.levelOrder(),r=e(t),l=new n(r);this.root=l.root}}const l=n,o=function t(e,r="",n=!0){null!==e&&(null!==e.right&&t(e.right,`${r}${n?"│   ":"    "}`,!1),console.log(`${r}${n?"└── ":"┌── "}${e.node}`),null!==e.left&&t(e.left,`${r}${n?"    ":"│   "}`,!0))};function i(t){o(t.root),t.isBalanced()?console.log("This tree is balanced."):console.log("This tree is unbalanced.")}function h(t){console.log(`Level order: ${t.levelOrder()}`),console.log(`Pre order: ${t.preOrder()}`),console.log(`Post order: ${t.postOrder()}`),console.log(`In order: ${t.inOrder()}`)}!function(){const t=function(){const t=[],e=Math.floor(10*Math.random()+6);for(let r=0;r<e;r++){const e=Math.floor(100*Math.random()+1);t.push(e)}return t}(),r=e(t),n=new l(r);i(n),h(n),function(t){const e=Math.floor(5*Math.random()+6);for(let r=0;r<e;r++){const e=Math.floor(900*Math.random()+101);t.insert(e)}}(n),i(n),n.rebalance(),i(n),h(n)}()})();